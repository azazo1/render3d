<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASM Render 3D - Ray Tracing</title>

    <style>
        /* å¼•å…¥å¤å¤åƒç´ å­—ä½“ (è¿™é‡Œä½¿ç”¨ä¸€ä¸ªé€šç”¨çš„ç±»ä¼¼å­—ä½“) */
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            /* è®¾å®šä¸€äº›è¡—æœºé£æ ¼çš„é¢œè‰²å˜é‡ */
            --arcade-red: #cc3333;
            --arcade-yellow: #ffcc00;
            --arcade-dark: #222;
            --arcade-screen: #000;
        }

        body {
            background-color: var(--arcade-dark);
            color: var(--arcade-yellow);
            font-family: 'VT323', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            /* ä¿è¯å æ®æ•´ä¸ªè§†å£é«˜åº¦ */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            color: var(--arcade-red);
            text-shadow: 2px 2px var(--arcade-dark);
            font-size: 3em;
            margin-bottom: 0.5em;
            letter-spacing: 5px;
        }

        /* è¡—æœºå±å¹•å®¹å™¨ */
        .arcade-cabinet {
            border: 15px solid var(--arcade-red);
            box-shadow: 0 0 50px rgba(255, 204, 0, 0.5), 0 0 20px var(--arcade-dark) inset;
            background-color: #000;
            /* å±å¹•èƒŒæ™¯ */
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: inline-block;
            /* é€‚åº”å†…å®¹å¤§å° */
        }

        /* åŸå§‹ canvas (ç”¨äº off-screen æ¸²æŸ“) */
        #rayTracingCanvas {
            display: none;
            /* éšè—åŸå§‹ canvas */
        }

        /* ç”¨äºæ˜¾ç¤ºç¼©æ”¾åå›¾åƒçš„ canvas */
        #displayCanvas {
            image-rendering: pixelated;
            /* å…³é”®ï¼šä¿æŒåƒç´ é”åˆ©ï¼Œä¸æ¨¡ç³Š */
            image-rendering: crisp-edges;
            width: min(70vh, 70vw);
            height: min(70vh, 70vw);
            background-color: var(--arcade-screen);
            border: 2px solid var(--arcade-yellow);
        }

        /* æŒ‰é”®æç¤ºåŒº */
        .controls {
            background-color: var(--arcade-dark);
            border: 3px dashed var(--arcade-yellow);
            padding: 7px 12px;
            text-align: center;
            font-size: 1.5em;
            border-radius: 5px;
            line-height: 1.6;
        }

        .controls strong {
            color: var(--arcade-red);
            margin-right: 5px;
        }

        div.container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            column-gap: 32px;
        }
    </style>
</head>

<body>
    <h1>Render 3D - Ray Tracing</h1>
    <div class="container">
        <input type="text" id="virtualInput" style="position: absolute; opacity: 0; pointer-events: none; top: -100px;">

        <div class="arcade-cabinet">
            <canvas id="rayTracingCanvas"></canvas>
            <canvas id="displayCanvas"></canvas>
        </div>

        <div class="controls">
            <h2>ğŸ•¹ï¸ æ§åˆ¶å°æŒ‡å—</h2>
            <p>
                <strong>WASD:</strong><br> å‰åå·¦å³ç§»åŠ¨<br>
                <strong>HLKJ:</strong><br> å·¦å³è½¬ / æŠ¬ä½å¤´<br>
                <strong>ç©ºæ ¼é”® / Shift:</strong><br> ä¸Šå‡ / ä¸‹é™<br>
            </p>
        </div>
    </div>

    <script type="module">
        import init, { RayTracing, Light, Sphere, Vec3, Action } from './pkg/render3d.js';

        const RENDER_WIDTH = 200;
        const RENDER_HEIGHT = 200;

        // åŸå§‹æ¸²æŸ“ç”»å¸ƒ (ç”¨äºè·å–æ•°æ®ï¼Œä½†ä¸æ˜¾ç¤º)
        const renderCanvas = document.getElementById("rayTracingCanvas");
        const renderCtx = renderCanvas.getContext('2d');
        renderCanvas.width = RENDER_WIDTH;
        renderCanvas.height = RENDER_HEIGHT;

        // æ˜¾ç¤ºç”»å¸ƒ (ç”¨äºç¼©æ”¾å¹¶æ˜¾ç¤ºæœ€ç»ˆå›¾åƒ)
        const displayCanvas = document.getElementById("displayCanvas");
        const displayCtx = displayCanvas.getContext('2d');

        let rt = null;

        function onCanvasClick(event) {
            event.preventDefault();
            // å¼ºåˆ¶å°†ç„¦ç‚¹è®¾ç½®åˆ°éšè—çš„è¾“å…¥æ¡†
            virtualInput.focus();
        }

        // --- å›¾åƒåå¤„ç†å’Œæ˜¾ç¤º ---
        function redraw() {
            if (!rt) return;

            // 1. ä» WASM æ¨¡å—è·å– 200x200 åƒç´ æ•°æ®
            let frame = rt.render_to_web_color();

            // 2. å°†æ•°æ®æ”¾å…¥åŸå§‹ canvas (å®é™…ä¸Šä¸éœ€è¦ï¼Œä½†ä¸ºäº†æ–¹ä¾¿ImageDataåˆ›å»º)
            const imageData = new ImageData(new Uint8ClampedArray(frame.buffer, frame.byteOffset, frame.byteLength), RENDER_WIDTH, RENDER_HEIGHT);
            renderCtx.putImageData(imageData, 0, 0);

            // 3. å°†åŸå§‹ canvas çš„å†…å®¹ç»˜åˆ¶åˆ°æ˜¾ç¤º canvas å¹¶æ”¾å¤§
            // ä½¿ç”¨ drawImage è¿›è¡Œç¡¬ä»¶åŠ é€Ÿçš„æ•´æ•°å€ç¼©æ”¾ï¼Œç¡®ä¿ image-rendering: pixelated ç”Ÿæ•ˆ
            displayCtx.drawImage(
                renderCanvas,
                0, 0, RENDER_WIDTH, RENDER_HEIGHT, // æºçŸ©å½¢ (åŸå§‹ 200x200)
                0, 0, displayCanvas.width, displayCanvas.height // ç›®æ ‡çŸ©å½¢ (ç¼©æ”¾åçš„ 800x800)
            );

            // å¾ªç¯è°ƒç”¨
            requestAnimationFrame(redraw);
        }

        // --- é”®ç›˜äº‹ä»¶å¤„ç† (ä¿æŒä¸å˜) ---
        function mapKey(code) {
            let action = null;
            switch (code) {
                // ... (wasd, space, ctrl, hjkl é€»è¾‘ä¸å˜) ...
                case 'w': case 'W': case 'ArrowUp': action = Action.CameraMoveForward; break;
                case 's': case 'S': case 'ArrowDown': action = Action.CameraMoveBackward; break;
                case 'a': case 'A': case 'ArrowLeft': action = Action.CameraMoveLeft; break;
                case 'd': case 'D': case 'ArrowRight': action = Action.CameraMoveRight; break;
                case ' ': action = Action.CameraMoveUp; break;
                case 'Shift': case 'ShiftLeft': case 'ShiftRight':
                case 'Control': case 'ControlLeft': case 'ControlRight':
                    action = Action.CameraMoveDown; break;
                case 'h': case 'H': action = Action.CameraRotationCCW; break;
                case 'l': case 'L': action = Action.CameraRotationCW; break;
                case 'k': case 'K': action = Action.CameraRotationUp; break;
                case 'j': case 'J': action = Action.CameraRotationDown; break;
                default: break;
            }
            return action;
        }

        function onKeyDown(evt) {
            let action = mapKey(evt.key);
            if (action !== null && rt !== null) {
                evt.preventDefault();
                rt.trigger_action(action);
            }
        }

        function onKeyUp(evt) {
            let action = mapKey(evt.key);
            if (action !== null && rt !== null) {
                evt.preventDefault();
                rt.withdraw_action(action);
            }
        }

        // --- åˆå§‹åŒ– ---
        (async () => {
            console.log("Loading wasm...");
            await init();
            console.log("Wasm loaded...");
            rt = RayTracing.new(RENDER_WIDTH, RENDER_HEIGHT, 42);
            rt.set_withdraw_actions_on_render(false);
            rt.move_camera_to(Vec3.new(0, 0, 3));
            rt.rotate_camera_to(Vec3.new(1, 0, -2));
            for (var i = 0; i < 10; ++i) {
                rt.put_sphere(Sphere.new(Vec3.new(i * 3, 0, 1), 1));
            }
            rt.put_light(Light.new(Vec3.new(0, 5, 4), 1));
            rt.put_light(Light.new(Vec3.new(0, -5, 4), 0.5));
            document.addEventListener("keydown", onKeyDown)
            document.addEventListener("keyup", onKeyUp)
            displayCanvas.addEventListener("click", onCanvasClick);

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            redraw();
        })();
    </script>

</body>

</html>